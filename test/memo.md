# links

* [低レイヤを知りたい人のためのCコンパイラ作成入門](https://www.sigbus.info/compilerbook)<br>
* [Intel operands](https://www.felixcloutier.com/x86/)

# tokenize
# parse
## alignment for aggressive type(union,struct)
* alignの決定方法<br>
集成体型（構造体、共用体）のalignは各メンバの中で最大のデータ型のsizeをとる。

* メンバのメモリ配置方法
** 共用体<br>
すべてのメンバはoffset=0で開始する。
** 構造体<br>
offset=0からメンバを順々に積み重ねる。
もし現在のoffsetが次のメンバのsizeの倍数でない場合、
現在のoffsetの直後にくる追加メンバの倍数までパディングを行い、倍数のとこにメンバを配置する。
　例１：offset=5、メンバsize=4の場合、+3をパディングし8バイト目から配置
　例２：offset=8、メンバsize=4の場合、すでに倍数なのでパディングを行わなずそのまま8バイト目に配置。

* 集大成型のsizeの決定方法
** 共用体<br>
alignと同値。
** 構造体<br>
すべてのメンバをメモリに配置したoffset、もし合計sizeがalignの倍数でない場合、不足分をパディングした値がsizeとなる。
　例：配置時のoffsetが6、alignが4の場合は2バイトパディングし8バイトeが全体のサイズとなる。

例1：共用体の場合
```
union myunion{
    char a; //4byte
    char *b; //8byte
    int c; //1byte
}
```
この場合、メモリ上の配置イメージは次の通りになる。
```
　12345678
a|□|
b|□□□□□□□□|
c|□□□□| 
```
一番サイズが大きいbの8バイトが共用体のalignとなる。
また共用体のsizeも同じく8バイトとなる。

例2：構造体の場合
```
union mystruct{
    char a; //1byte
    short b; //2byte
    short c; //2byte
    int d; //4byte
    char e; //1byte
}
```
この場合、メモリ上の配置イメージは次の通りになる。
```

 a　b　c      d    e
|□|□□|□□|___|□□□□|□|____
 1 12 12 123 1234 1 123

```
一番sizeが大きいdが構造体のalign4バイトとなる。
またc配置直後はoffsetが5バイトで、dの4バイトの倍数ではないので次に大きい倍数8バイト目までパディングを行う。
また全て配置後のoffsetは13となりalingの倍数でないため、次に大きい16までパディングを行う。よって全体sizeは16。



# codegen
## register list
おおまかなレジスタの配置は次の通り。
```
63                        31            15      7      0 bit
 -------------------------------------------------------
 | rax                     |  eax     ax |  ah  |   al |
 -------------------------------------------------------
 | rbx                     |  ebx     bx |  bh  |   bl |
 -------------------------------------------------------
 | rcx                     |  ecx     cx |  ch  |   cl |
 -------------------------------------------------------
 | rdx                     |  edx     dx |  dh  |   dl |
 -------------------------------------------------------
 | rsi                     |  esi     si |      |  sil |
 -------------------------------------------------------
 | rdi                     |  edi     di |      |  dil |
 -------------------------------------------------------
 | rbp                     |  ebp     bp |      |  bpl |
 -------------------------------------------------------
 | rsp                     |  esp     sp |      |  spl |
 -------------------------------------------------------
 |  r8                     |  r8d    r8w |      |  r8b |
 -------------------------------------------------------
 |  r9                     |  r9d    r9w |      |  r9b |
 -------------------------------------------------------
 | r10                     | r10d   r10w |      | r10b |
 -------------------------------------------------------
 | r11                     | r11d   r11w |      | r11b |
 -------------------------------------------------------
 | r12                     | r12d   r12w |      | r12b |
 -------------------------------------------------------
 | r13                     | r13d   r13w |      | r13b |
 -------------------------------------------------------
 | r14                     | r14d   r14w |      | r14b |
 -------------------------------------------------------
 | r15                     | r15d   r15w |      | r15b |
 -------------------------------------------------------
```

## mov operand
mov系命令に種類が多すぎるので各キーワードの解説。

* レジスタのサイズに属するキーワード

|略称|意味|補足|
|---|---|---|
|b|byte（8bit）|al, bl, cl|
|w|word（16bit）|ax, bx, cx|
|d|double word（32bit）|eax, ebx, ecx|
|l|long（32bit）|eax, ebx, ecx|
|q|quad（64bit）|rax, rbx, rcx|

* 符号変換に関するキーワード

|略称|意味|補足|
|---|---|---|
|s|sign-extend（符号拡張）|負数を保つ|
|z|zero-extend（ゼロ拡張）|常に正数|

movオペランド例： 
* `movsbl al,eax`<br>
8bit→32bitへの符号付き拡張
* `movzbl ax,eax`<br>
8bit→32bitへの符号なし拡張
* `movsxd eax,rax`<br>
32bit→64bitへの符号付き拡張（オペランドのサイズ表記が元→先ではなく先→元になってる例外）

